(* This fslex file was machine-generated by the BNF converter *)
{
module FsLatte.Front.Lex
open FsLatte.Front.Par
open System
open System.Collections.Generic
open Microsoft.FSharp.Text.Lexing

let symbol_table =
    Map.ofList
        [
            ("(", LPAREN);
            (")", RPAREN);
            (",", COMMA);
            ("{", LBRACKET);
            ("}", RBRACKET);
            (";", SEMICOLON);
            ("=", SYMB7);
            ("++", SYMB8);
            ("--", SYMB9);
            ("-", SYMB10);
            ("!", SYMB11);
            ("&&", SYMB12);
            ("||", SYMB13);
            ("+", SYMB14);
            ("*", SYMB15);
            ("/", SYMB16);
            ("%", SYMB17);
            ("<", SYMB18);
            ("<=", SYMB19);
            (">", SYMB20);
            (">=", SYMB21);
            ("==", SYMB22);
            ("!=", SYMB23)
        ]

let resword_table =
    Map.ofList
        [
            ("boolean", TOK_boolean);
            ("else", TOK_else);
            ("false", TOK_false);
            ("if", TOK_if);
            ("int", TOK_int);
            ("return", TOK_return);
            ("string", TOK_string);
            ("true", TOK_true);
            ("void", TOK_void);
            ("while", TOK_while)
        ]


let unescapeInitTail (s:string) : string =
  let rec unesc s =
    match s with
    | '\\'::c::cs when List.contains c ['\"'; '\\'; '\''] -> c :: unesc cs
    | '\\'::'n'::cs  -> '\n' :: unesc cs
    | '\\'::'t'::cs  -> '\t' :: unesc cs
    | '\"'::[]    -> []
    | c::cs      -> c :: unesc cs
    | _         -> []
  s.ToCharArray() |> List.ofArray |> List.tail |> unesc |> Array.ofList |> String

let incr_lineno (lexbuf:LexBuffer<_>) : unit =
    lexbuf.EndPos <- lexbuf.EndPos.NextLine
let lexeme (lexbuf:LexBuffer<_>) : string =
    LexBuffer<_>.LexemeString lexbuf
}

let l = ['a'-'z' 'A'-'Z' '\192'-'\214' '\216'-'\246' '\248'-'\255']    (*  isolatin1 letter FIXME *)
let c = ['A'-'Z' '\192'-'\214' '\216'-'\221']  (*  capital isolatin1 letter FIXME *)
let s = ['a'-'z' '\222'-'\246' '\248'-'\255'] (*  small isolatin1 letter FIXME *)
let d = ['0'-'9']                (*  digit *)
let i = l | d | ['_' '\'']          (*  identifier character *)
let noStar = ['\000' - '\041' '\043'-'\255']
let noSlash = ['\000'- '\046' '\048'-'\255']
let u = ['\000'-'\255']           (* universal: any character *)
let u1 = ['\000'-'\009' '\011'-'\033' '\035'-'\091' '\093'-'\255']
let u2 = ['\000'-'\038' '\040'-'\091' '\093'-'\255']
let rsyms =    (* reserved words consisting of special symbols *)
            "(" | ")" | "," | "{" | "}" | ";" | "=" | "++" | "--" | "-" | "!" | "&&" | "||" | "+" | "*" | "/" | "%" | "<" | "<=" | ">" | ">=" | "==" | "!="

rule token =
  parse "#" ([^'\n'])* {token lexbuf}
      | "//" ([^'\n'])* {token lexbuf}
      | "/*" (noStar | '*' noSlash)* '*'* "*/" {token lexbuf}
      | rsyms {let id = lexeme lexbuf
               try Map.find id symbol_table with
                 :? KeyNotFoundException -> failwith ("internal lexer error: reserved symbol " + id + " not found in hashtable")}
      | l i* {let id = lexeme lexbuf
              try Map.find id resword_table with
                 :? KeyNotFoundException -> ID id}
      | d+ {let i = lexeme lexbuf in TOK_Integer (int i)}
      | d+ '.' d+ ('e' ('-')? d+)? {let f = lexeme lexbuf in TOK_Double (float f)}
      | '\"' (u1 | ('\\' ('\"' | '\\' | '\'' | 'n' | 't')))* '\"' {let s = lexeme lexbuf in TOK_String (unescapeInitTail s)}
      | '\'' (u2 | ('\\' ('\\' | '\'' | 'n' | 't'))) '\'' {let s = lexeme lexbuf in TOK_Char s.[1]}
      | [' ' '\t'] {token lexbuf}
      | "\r\n" | '\n' {incr_lineno lexbuf; token lexbuf}
      | eof  {EOF}
