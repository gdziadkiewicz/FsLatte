/* This fsyacc file was machine-generated by the BNF converter */
%{
open FsLatte.Model.Abs
%}


%token LPAREN /* ( */
%token RPAREN /* ) */
%token COMMA /* , */
%token LBRACKET /* { */
%token RBRACKET /* } */
%token SEMICOLON /* ; */
%token SYMB7 /* = */
%token SYMB8 /* ++ */
%token SYMB9 /* -- */
%token SYMB10 /* - */
%token SYMB11 /* ! */
%token SYMB12 /* && */
%token SYMB13 /* || */
%token SYMB14 /* + */
%token SYMB15 /* * */
%token SYMB16 /* / */
%token SYMB17 /* % */
%token SYMB18 /* < */
%token SYMB19 /* <= */
%token SYMB20 /* > */
%token SYMB21 /* >= */
%token SYMB22 /* == */
%token SYMB23 /* != */
%token EOF

%token <string> ID
%token <string> TOK_String
%token <int> TOK_Integer
%token <float> TOK_Double
%token <char> TOK_Char
%token TOK_boolean TOK_else TOK_false TOK_if TOK_int TOK_return TOK_string TOK_true TOK_void TOK_while
%type <FsLatte.Model.Abs.Program> pProgram

%start pProgram

%%
pProgram: Program EOF { $1 }
        | error { raise (BnfcUtil.ParseErrorException parseState.ResultRange) }

Program: TopDefList { Program $1 }

TopDef: Type Ident LPAREN ArgList RPAREN Block { FnDef ($1, $2, $4, $6) } 

TopDefList: TopDef { (fun x -> [x]) $1 }  /* TODO: fix */
          | TopDef TopDefList { (fun (x,xs) -> x::xs) ($1, $2) }

Ident: ID { Ident $1 }

Arg: Type Ident { Arg ($1, $2) }

ArgList: { [] }
       | Arg { (fun x -> [x]) $1 } /* TODO: fix */
       | Arg COMMA ArgList { (fun (x,xs) -> x::xs) ($1, $3) }

Block: LBRACKET StmtList RBRACKET { Block (List.rev $2) }

StmtList: { [] }
        | StmtList Stmt { (fun (x,xs) -> x::xs) ($2, $1) }

Stmt: SEMICOLON { Empty }
    | Block { BStmt $1 }
    | Type ItemList SEMICOLON { Decl ($1, $2) }
    | Ident SYMB7 Expr SEMICOLON { Ass ($1, $3) }
    | Ident SYMB8 SEMICOLON { Incr $1 }
    | Ident SYMB9 SEMICOLON { Decr $1 }
    | TOK_return Expr SEMICOLON { Ret $2 }
    | TOK_return SEMICOLON { VRet  }
    | TOK_if LPAREN Expr RPAREN Stmt { Cond ($3, $5) }
    | TOK_if LPAREN Expr RPAREN Stmt TOK_else Stmt { CondElse ($3, $5, $7) }
    | TOK_while LPAREN Expr RPAREN Stmt { While ($3, $5) }
    | Expr SEMICOLON { SExp $1 }

Item: Ident { NoInit $1 } 
    | Ident SYMB7 Expr { Init ($1, $3) }

ItemList: Item { (fun x -> [x]) $1 } 
        | Item COMMA ItemList { (fun (x,xs) -> x::xs) ($1, $3) }

Type: TOK_int     { Int }
    | TOK_string  { Str }
    | TOK_boolean { Bool }
    | TOK_void    { Void }

TypeList: { [] }
        | Type { (fun x -> [x]) $1 }
        | Type COMMA TypeList { (fun (x,xs) -> x::xs) ($1, $3) }

Expr6: Ident { EVar $1 } 
     | TOK_Integer { ELitInt $1 }
     | TOK_true { ELitTrue  }
     | TOK_false { ELitFalse  }
     | Ident LPAREN ExprList RPAREN { EApp ($1, $3) }
     | TOK_String { EString $1 }
     | LPAREN Expr RPAREN {  $2 }

Expr5: SYMB10 Expr6 { Neg $2 } 
     | SYMB11 Expr6 { Not $2 }
     | Expr6 { $1 }

Expr4: Expr4 MulOp Expr5 { EMul ($1, $2, $3) } 
     | Expr5 { $1 }

Expr3: Expr3 AddOp Expr4 { EAdd ($1, $2, $3) } 
     | Expr4 { $1 }

Expr2: Expr2 RelOp Expr3 { ERel ($1, $2, $3) } 
     | Expr3 { $1 }

Expr1: Expr2 SYMB12 Expr1 { EAnd ($1, $3) } 
     | Expr2 { $1 }

Expr: Expr1 SYMB13 Expr { EOr ($1, $3) } 
    | Expr1 { $1 }

ExprList: { [] }
        | Expr { (fun x -> [x]) $1 }
        | Expr COMMA ExprList { (fun (x,xs) -> x::xs) ($1, $3) }

AddOp: SYMB14 { Plus  }
     | SYMB10 { Minus }

MulOp: SYMB15 { Times }
     | SYMB16 { Div }
     | SYMB17 { Mod }

RelOp: SYMB18 { LTH }
     | SYMB19 { LE }
     | SYMB20 { GTH }
     | SYMB21 { GE }
     | SYMB22 { EQU }
     | SYMB23 { NE }